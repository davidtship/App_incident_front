import{k as ne,R as yt,r as _}from"./index-B6sDybhi.js";var ut={exports:{}},lt={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ut;function re(){if(Ut)return lt;Ut=1;var t=ne();function e(a,l){return a===l&&(a!==0||1/a===1/l)||a!==a&&l!==l}var n=typeof Object.is=="function"?Object.is:e,r=t.useState,u=t.useEffect,s=t.useLayoutEffect,i=t.useDebugValue;function p(a,l){var f=l(),C=r({inst:{value:f,getSnapshot:l}}),d=C[0].inst,M=C[1];return s(function(){d.value=f,d.getSnapshot=l,R(d)&&M({inst:d})},[a,f,l]),u(function(){return R(d)&&M({inst:d}),a(function(){R(d)&&M({inst:d})})},[a]),i(f),f}function R(a){var l=a.getSnapshot;a=a.value;try{var f=l();return!n(a,f)}catch{return!0}}function D(a,l){return l()}var T=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?D:p;return lt.useSyncExternalStore=t.useSyncExternalStore!==void 0?t.useSyncExternalStore:T,lt}var Wt;function se(){return Wt||(Wt=1,ut.exports=re()),ut.exports}var oe=se(),Mt=Object.prototype.hasOwnProperty;function St(t,e){var n,r;if(t===e)return!0;if(t&&e&&(n=t.constructor)===e.constructor){if(n===Date)return t.getTime()===e.getTime();if(n===RegExp)return t.toString()===e.toString();if(n===Array){if((r=t.length)===e.length)for(;r--&&St(t[r],e[r]););return r===-1}if(!n||typeof t=="object"){r=0;for(n in t)if(Mt.call(t,n)&&++r&&!Mt.call(e,n)||!(n in e)||!St(t[n],e[n]))return!1;return Object.keys(e).length===r}}return t!==t&&e!==e}const j=new WeakMap,U=()=>{},y=U(),mt=Object,c=t=>t===y,N=t=>typeof t=="function",W=(t,e)=>({...t,...e}),$t=t=>N(t.then),ft={},st={},Ct="undefined",it=typeof window!=Ct,Tt=typeof document!=Ct,ie=()=>it&&typeof window.requestAnimationFrame!=Ct,Jt=(t,e)=>{const n=j.get(t);return[()=>!c(e)&&t.get(e)||ft,r=>{if(!c(e)){const u=t.get(e);e in st||(st[e]=u),n[5](e,W(u,r),u||ft)}},n[6],()=>!c(e)&&e in st?st[e]:!c(e)&&t.get(e)||ft]};let vt=!0;const ae=()=>vt,[gt,wt]=it&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[U,U],ce=()=>{const t=Tt&&document.visibilityState;return c(t)||t!=="hidden"},ue=t=>(Tt&&document.addEventListener("visibilitychange",t),gt("focus",t),()=>{Tt&&document.removeEventListener("visibilitychange",t),wt("focus",t)}),le=t=>{const e=()=>{vt=!0,t()},n=()=>{vt=!1};return gt("online",e),gt("offline",n),()=>{wt("online",e),wt("offline",n)}},fe={isOnline:ae,isVisible:ce},de={initFocus:ue,initReconnect:le},qt=!yt.useId,Z=!it||"Deno"in globalThis,Ee=t=>ie()?window.requestAnimationFrame(t):setTimeout(t,1),dt=Z?_.useEffect:_.useLayoutEffect,Et=typeof navigator<"u"&&navigator.connection,kt=!Z&&Et&&(["slow-2g","2g"].includes(Et.effectiveType)||Et.saveData),ot=new WeakMap,ht=(t,e)=>mt.prototype.toString.call(t)===`[object ${e}]`;let he=0;const _t=t=>{const e=typeof t,n=ht(t,"Date"),r=ht(t,"RegExp"),u=ht(t,"Object");let s,i;if(mt(t)===t&&!n&&!r){if(s=ot.get(t),s)return s;if(s=++he+"~",ot.set(t,s),Array.isArray(t)){for(s="@",i=0;i<t.length;i++)s+=_t(t[i])+",";ot.set(t,s)}if(u){s="#";const p=mt.keys(t).sort();for(;!c(i=p.pop());)c(t[i])||(s+=i+":"+_t(t[i])+",");ot.set(t,s)}}else s=n?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return s},Dt=t=>{if(N(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?_t(t):"",[t,e]};let pe=0;const Ot=()=>++pe,zt=0,Bt=1,Gt=2,Re=3;var Q={__proto__:null,ERROR_REVALIDATE_EVENT:Re,FOCUS_EVENT:zt,MUTATE_EVENT:Gt,RECONNECT_EVENT:Bt};async function Kt(...t){const[e,n,r,u]=t,s=W({populateCache:!0,throwOnError:!0},typeof u=="boolean"?{revalidate:u}:u||{});let i=s.populateCache;const p=s.rollbackOnError;let R=s.optimisticData;const D=l=>typeof p=="function"?p(l):p!==!1,T=s.throwOnError;if(N(n)){const l=n,f=[],C=e.keys();for(const d of C)!/^\$(inf|sub)\$/.test(d)&&l(e.get(d)._k)&&f.push(d);return Promise.all(f.map(a))}return a(n);async function a(l){const[f]=Dt(l);if(!f)return;const[C,d]=Jt(e,f),[M,o,tt,Y]=j.get(e),P=()=>{const I=M[f];return(N(s.revalidate)?s.revalidate(C().data,l):s.revalidate!==!1)&&(delete tt[f],delete Y[f],I&&I[0])?I[0](Gt).then(()=>C().data):C().data};if(t.length<3)return P();let g=r,A;const k=Ot();o[f]=[k,0];const m=!c(R),H=C(),L=H.data,$=H._c,q=c($)?L:$;if(m&&(R=N(R)?R(q,L):R,d({data:R,_c:q})),N(g))try{g=g(q)}catch(I){A=I}if(g&&$t(g))if(g=await g.catch(I=>{A=I}),k!==o[f][0]){if(A)throw A;return g}else A&&m&&D(A)&&(i=!0,d({data:q,_c:y}));if(i&&!A)if(N(i)){const I=i(g,q);d({data:I,error:y,_c:y})}else d({data:g,error:y,_c:y});if(o[f][1]=Ot(),Promise.resolve(P()).then(()=>{d({_c:y})}),A){if(T)throw A;return}return g}}const Ht=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},Se=(t,e)=>{if(!j.has(t)){const n=W(de,e),r={},u=Kt.bind(y,t);let s=U;const i={},p=(T,a)=>{const l=i[T]||[];return i[T]=l,l.push(a),()=>l.splice(l.indexOf(a),1)},R=(T,a,l)=>{t.set(T,a);const f=i[T];if(f)for(const C of f)C(a,l)},D=()=>{if(!j.has(t)&&(j.set(t,[r,{},{},{},u,R,p]),!Z)){const T=n.initFocus(setTimeout.bind(y,Ht.bind(y,r,zt))),a=n.initReconnect(setTimeout.bind(y,Ht.bind(y,r,Bt)));s=()=>{T&&T(),a&&a(),j.delete(t)}}};return D(),[t,u,D,s]}return[t,j.get(t)[4]]},me=(t,e,n,r,u)=>{const s=n.errorRetryCount,i=u.retryCount,p=~~((Math.random()+.5)*(1<<(i<8?i:8)))*n.errorRetryInterval;!c(s)&&i>s||setTimeout(r,p,u)},Te=St,[Yt,ve]=Se(new Map),ge=W({onLoadingSlow:U,onSuccess:U,onError:U,onErrorRetry:me,onDiscarded:U,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:kt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:kt?5e3:3e3,compare:Te,isPaused:()=>!1,cache:Yt,mutate:ve,fallback:{}},fe),we=(t,e)=>{const n=W(t,e);if(e){const{use:r,fallback:u}=t,{use:s,fallback:i}=e;r&&s&&(n.use=r.concat(s)),u&&i&&(n.fallback=W(u,i))}return n},_e=_.createContext({}),Oe="$inf$",Xt=it&&window.__SWR_DEVTOOLS_USE__,ye=Xt?window.__SWR_DEVTOOLS_USE__:[],Ce=()=>{Xt&&(window.__SWR_DEVTOOLS_REACT__=yt)},De=t=>N(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],Ae=()=>W(ge,_.useContext(_e)),Ve=t=>(e,n,r)=>t(e,n&&((...s)=>{const[i]=Dt(e),[,,,p]=j.get(Yt);if(i.startsWith(Oe))return n(...s);const R=p[i];return c(R)?n(...s):(delete p[i],R)}),r),Ie=ye.concat(Ve),Le=t=>function(...n){const r=Ae(),[u,s,i]=De(n),p=we(r,i);let R=t;const{use:D}=p,T=(D||[]).concat(Ie);for(let a=T.length;a--;)R=T[a](R);return R(u,s||p.fetcher||null,p)},be=(t,e,n)=>{const r=e[t]||(e[t]=[]);return r.push(n),()=>{const u=r.indexOf(n);u>=0&&(r[u]=r[r.length-1],r.pop())}};Ce();const pt=yt.use||(t=>{switch(t.status){case"pending":throw t;case"fulfilled":return t.value;case"rejected":throw t.reason;default:throw t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t}}),Rt={dedupe:!0},Ne=(t,e,n)=>{const{cache:r,compare:u,suspense:s,fallbackData:i,revalidateOnMount:p,revalidateIfStale:R,refreshInterval:D,refreshWhenHidden:T,refreshWhenOffline:a,keepPreviousData:l}=n,[f,C,d,M]=j.get(r),[o,tt]=Dt(t),Y=_.useRef(!1),P=_.useRef(!1),g=_.useRef(o),A=_.useRef(e),k=_.useRef(n),m=()=>k.current,H=()=>m().isVisible()&&m().isOnline(),[L,$,q,I]=Jt(r,o),J=_.useRef({}).current,et=c(i)?c(n.fallback)?y:n.fallback[o]:i,At=(E,h)=>{for(const w in J){const S=w;if(S==="data"){if(!u(E[S],h[S])&&(!c(E[S])||!u(rt,h[S])))return!1}else if(h[S]!==E[S])return!1}return!0},Vt=_.useMemo(()=>{const E=!o||!e?!1:c(p)?m().isPaused()||s?!1:R!==!1:p,h=O=>{const F=W(O);return delete F._k,E?{isValidating:!0,isLoading:!0,...F}:F},w=L(),S=I(),b=h(w),K=w===S?b:h(S);let v=b;return[()=>{const O=h(L());return At(O,v)?(v.data=O.data,v.isLoading=O.isLoading,v.isValidating=O.isValidating,v.error=O.error,v):(v=O,O)},()=>K]},[r,o]),z=oe.useSyncExternalStore(_.useCallback(E=>q(o,(h,w)=>{At(w,h)||E()}),[r,o]),Vt[0],Vt[1]),It=!Y.current,Qt=f[o]&&f[o].length>0,B=z.data,G=c(B)?et&&$t(et)?pt(et):et:B,nt=z.error,Lt=_.useRef(G),rt=l?c(B)?Lt.current:B:G,bt=Qt&&!c(nt)?!1:It&&!c(p)?p:m().isPaused()?!1:s?c(G)?!1:R:c(G)||R,Nt=!!(o&&e&&It&&bt),Zt=c(z.isValidating)?Nt:z.isValidating,te=c(z.isLoading)?Nt:z.isLoading,X=_.useCallback(async E=>{const h=A.current;if(!o||!h||P.current||m().isPaused())return!1;let w,S,b=!0;const K=E||{},v=!d[o]||!K.dedupe,O=()=>qt?!P.current&&o===g.current&&Y.current:o===g.current,F={isValidating:!1,isLoading:!1},xt=()=>{$(F)},jt=()=>{const V=d[o];V&&V[1]===S&&delete d[o]},Pt={isValidating:!0};c(L().data)&&(Pt.isLoading=!0);try{if(v&&($(Pt),n.loadingTimeout&&c(L().data)&&setTimeout(()=>{b&&O()&&m().onLoadingSlow(o,n)},n.loadingTimeout),d[o]=[h(tt),Ot()]),[w,S]=d[o],w=await w,v&&setTimeout(jt,n.dedupingInterval),!d[o]||d[o][1]!==S)return v&&O()&&m().onDiscarded(o),!1;F.error=y;const V=C[o];if(!c(V)&&(S<=V[0]||S<=V[1]||V[1]===0))return xt(),v&&O()&&m().onDiscarded(o),!1;const x=L().data;F.data=u(x,w)?x:w,v&&O()&&m().onSuccess(w,o,n)}catch(V){jt();const x=m(),{shouldRetryOnError:at}=x;x.isPaused()||(F.error=V,v&&O()&&(x.onError(V,o,x),(at===!0||N(at)&&at(V))&&(!m().revalidateOnFocus||!m().revalidateOnReconnect||H())&&x.onErrorRetry(V,o,x,ee=>{const ct=f[o];ct&&ct[0]&&ct[0](Q.ERROR_REVALIDATE_EVENT,ee)},{retryCount:(K.retryCount||0)+1,dedupe:!0})))}return b=!1,xt(),!0},[o,r]),Ft=_.useCallback((...E)=>Kt(r,g.current,...E),[]);if(dt(()=>{A.current=e,k.current=n,c(B)||(Lt.current=B)}),dt(()=>{if(!o)return;const E=X.bind(y,Rt);let h=0;const S=be(o,f,(b,K={})=>{if(b==Q.FOCUS_EVENT){const v=Date.now();m().revalidateOnFocus&&v>h&&H()&&(h=v+m().focusThrottleInterval,E())}else if(b==Q.RECONNECT_EVENT)m().revalidateOnReconnect&&H()&&E();else{if(b==Q.MUTATE_EVENT)return X();if(b==Q.ERROR_REVALIDATE_EVENT)return X(K)}});return P.current=!1,g.current=o,Y.current=!0,$({_k:tt}),bt&&(c(G)||Z?E():Ee(E)),()=>{P.current=!0,S()}},[o]),dt(()=>{let E;function h(){const S=N(D)?D(L().data):D;S&&E!==-1&&(E=setTimeout(w,S))}function w(){!L().error&&(T||m().isVisible())&&(a||m().isOnline())?X(Rt).then(h):h()}return h(),()=>{E&&(clearTimeout(E),E=-1)}},[D,T,a,o]),_.useDebugValue(rt),s&&c(G)&&o){if(!qt&&Z)throw new Error("Fallback data is required when using Suspense in SSR.");A.current=e,k.current=n,P.current=!1;const E=M[o];if(!c(E)){const h=Ft(E);pt(h)}if(c(nt)){const h=X(Rt);c(rt)||(h.status="fulfilled",h.value=!0),pt(h)}else throw nt}return{mutate:Ft,get data(){return J.data=!0,rt},get error(){return J.error=!0,nt},get isValidating(){return J.isValidating=!0,Zt},get isLoading(){return J.isLoading=!0,te}}},xe=Le(Ne),je=t=>fetch(t).then(e=>{if(!e.ok)throw new Error("Failed to fetch the data");return e.json()}),Pe=(t,e)=>fetch(t,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)}).then(n=>{if(!n.ok)throw new Error("Failed to post data");return n.json()}),Ue=(t,e)=>fetch(t,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)}).then(n=>{if(!n.ok)throw new Error("Failed to updated data");return n.json()}),We=(t,e)=>fetch(t,{method:"DELETE",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)}).then(n=>{if(!n.ok)throw new Error("Failed to delete data");return n.json()});export{Ue as a,We as d,je as g,Pe as p,xe as u};
